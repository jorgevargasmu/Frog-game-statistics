---
title: "Frog Game Generalized Mixed Modeling"
author: "JMG"
date: "`r Sys.Date()`"
output: html_document
---
```{r setup, include=FALSE}
library(lme4)
library(ggplot2)
library(performance)
library(DHARMa)
library(lmerTest)
library(tidyverse)
library(emmeans)
library(gridExtra)
library(ROCR)
# Define a function for plotting residuals diagnostics
plot_residuals_diagnostics <- function(model) {
  # Ensure the model is of class 'merMod' from lme4 package
  if (!inherits(model, "merMod")) {
    stop("The provided model is not a valid 'merMod' object from lme4.")
  }
  
  # Create a dataframe of residuals and fitted values from the model
  residuals_df <- data.frame(
    Residuals = residuals(model),
    Fitted = fitted(model)
  )
  
  # Plot histogram of residuals
  p1 <- ggplot(residuals_df, aes(x = Residuals)) +
    geom_histogram(bins = 30, fill = "blue", color = "black") +
    labs(title = "Histogram of Residuals", x = "Residuals", y = "Frequency")
  print(p1)
  
  # QQ plot for checking normality of residuals
  qqnorm(residuals_df$Residuals)
  qqline(residuals_df$Residuals, col = "red", lwd = 2)

  # Plot of residuals vs. fitted values
  p3 <- ggplot(residuals_df, aes(x = Fitted, y = Residuals)) +
    geom_point() +
    geom_smooth(method = "lm", col = "red") +
    labs(title = "Residuals vs. Fitted Values", x = "Fitted Values", y = "Residuals")
  print(p3)
}
```

```{r }
data <- read_csv("/Users/jorgevargasmutizabal/Desktop/Frog game statistics/R Analysis Frog/filtered_data.csv")

str(data)

data <- data %>%
  mutate(
    Player_ID = as.factor(Player_ID),          # Convert to factor
    LexTale = as.numeric(LexTale),              # Convert to numeric
    Game_Version = as.factor(Game_Version),     # Convert to factor
    Game_Level = as.factor(Game_Level),        # Convert to factor
    Phrase_Condition = as.factor(Phrase_Condition), # Convert to factor
    Question_Num = as.numeric(Question_Num),    # Convert to numeric
    Answer = as.numeric(Answer),                 # Convert to factor
    Reaction_Time = as.numeric(Reaction_Time)   # Convert to numeric
  )

# Verify changes
str(data)

```


## 0. What is the average reaction time marginalizing over everything?
### Oa: rt ~ 1 + (1 | participant)

```{r }
model1 <- lmer(Reaction_Time ~ 1 + (1 | Player_ID), data = data)

# Obtain and print a summary of the model to examine fixed and random effects
print(summary(model1))

#Diagnostic plots
plot_residuals_diagnostics(model1)

# Model diagnostics
check_model(model1)
```

## 1. Does learning take place?
### 1b: rt ~ 1 + time + (1 + time | participant)

```{r }
model2 <- lmer(Reaction_Time ~ 1 + Question_Num + (1 + Question_Num | Player_ID), data = data)

# Obtain and print a summary of the model to examine fixed and random effects
print(summary(model2))

#Diagnostic plots
plot_residuals_diagnostics(model2)

# Diagnostic checks - Simulating residuals to validate model assumptions
residuals_simulation <- simulateResiduals(fittedModel = model2, n = 500)
plot(residuals_simulation)

# Model diagnostics
check_model(model2)

# Check for influential cases potentially affecting the model
#influence_measures <- influence(model3)
#plot(influence_measures, which = "cook")

# If assumptions are not met, consider re-fitting the model with transformations or different specifications
# model_revised <- update(model, . ~ . + log(Reaction_Time))
# print(summary(model_revised))

# Model interpretation - examining fixed and random effects
#fixed_effects <- fixef(model3)
#random_effects <- ranef(model3)

# Printing fixed effects for interpretation
#print(fixed_effects)

# Printing random effects for interpretation
#print(random_effects)

# Get estimated marginal means for specific values of Question_Num
emm_results <- emmeans(model2, specs = ~ Question_Num, at = list(Question_Num = seq(min(data$Question_Num), max(data$Question_Num), by = 10)))

# Summarize the results
summary(emm_results)

# Plot the estimated marginal means
plot(emm_results)
```
```{r }
# Create a plot of Reaction_Time vs. Question_Num with a regression line
ggplot(data, aes(x = Question_Num, y = Reaction_Time)) +
  geom_point(alpha = 0.3) +
  geom_smooth(method = "lm", se = TRUE, color = "blue") +
  labs(title = "Reaction Time vs. Question Number",
       x = "Question Number",
       y = "Reaction Time")
```

## 2. Which condition is the hardest overall?
### 2a: rt - 1 + condition + (1 + condition | participant)


```{r }
model3 <- lmer(Reaction_Time ~ 1 + Phrase_Condition + (1 + Phrase_Condition | Player_ID), data = data)

# Obtain and print a summary of the model to examine fixed and random effects
print(summary(model3))

#Diagnostic plots
plot_residuals_diagnostics(model3)

# Diagnostic checks - Simulating residuals to validate model assumptions
residuals_simulation <- simulateResiduals(fittedModel = model3, n = 500)
plot(residuals_simulation)

# Model diagnostics
check_model(model3)

# Check for influential cases potentially affecting the model
#influence_measures <- influence(model3)
#plot(influence_measures, which = "cook")

# If assumptions are not met, consider re-fitting the model with transformations or different specifications
# model_revised <- update(model, . ~ . + log(Reaction_Time))
# print(summary(model_revised))

# Model interpretation - examining fixed and random effects
#fixed_effects <- fixef(model3)
#random_effects <- ranef(model3)

# Printing fixed effects for interpretation
#print(fixed_effects)

# Printing random effects for interpretation
#print(random_effects)

# Conducting pairwise comparisons of phrase conditions using estimated marginal means
emm_results <- emmeans(model3, specs = ~ Phrase_Condition)
summary(emm_results)
pairwise_comparisons <- emmeans(model3, specs = pairwise ~ Phrase_Condition)
summary(pairwise_comparisons)
plot(emm_results)
```


```{r }
# Create a boxplot
ggplot(data, aes(x = Phrase_Condition, y = Reaction_Time, fill = Phrase_Condition)) +
  geom_boxplot() +
  labs(title = "Reaction Times by Phrase Condition", x = "Phrase Condition", y = "Reaction Time (seconds)") +
  theme_minimal()
```

```{r }
# Calculate average reaction times per player per condition
avg_reaction_times <- data %>%
  group_by(Player_ID, Phrase_Condition) %>%
  summarise(Avg_Reaction_Time = mean(Reaction_Time), .groups = 'drop')

# Interaction plot
ggplot(avg_reaction_times, aes(x = Phrase_Condition, y = Avg_Reaction_Time, group = Player_ID, color = Phrase_Condition)) +
  geom_line(alpha = 0.5) +  # Slightly transparent to see overlapping lines
  geom_point() +
  labs(title = "Interaction of Phrase Condition and Player on Reaction Times", x = "Phrase Condition", y = "Average Reaction Time (seconds)") +
  theme_minimal()
```

## 3. Does the version of the experiment cause different outcomes?

```{r}
model8 <- lmer(Reaction_Time ~ 1 + Game_Version + (1 | Player_ID), data = data)

# Obtain and print a summary of the model to examine fixed and random effects
print(summary(model8))

#Diagnostic plots
plot_residuals_diagnostics(model8)

# Diagnostic checks - Simulating residuals to validate model assumptions
residuals_simulation <- simulateResiduals(fittedModel = model8, n = 500)
plot(residuals_simulation)

# Model diagnostics
check_model(model8)

# Check for influential cases potentially affecting the model
#influence_measures <- influence(model4)
#plot(influence_measures, which = "cook")

# If assumptions are not met, consider re-fitting the model with transformations or different specifications
# model_revised <- update(model, . ~ . + log(Reaction_Time))
# print(summary(model_revised))

# Model interpretation - examining fixed and random effects
fixed_effects <- fixef(model8)
random_effects <- ranef(model8)

```


## How does the effect of condition vary depending on the version?
### 4b: rt ~ 1 + condition * version + (1 + condition | participant)

```{r }
#This doesnt work:
#model4 <- lmer(Reaction_Time ~ 1 + Phrase_Condition * Game_Version + (1 + Phrase_Condition | Player_ID), data = data)

model4 <- lmer(Reaction_Time ~ 1 + Phrase_Condition * Game_Version + (1 | Player_ID), data = data)

# Obtain and print a summary of the model to examine fixed and random effects
print(summary(model4))

#Diagnostic plots
plot_residuals_diagnostics(model4)

# Diagnostic checks - Simulating residuals to validate model assumptions
residuals_simulation <- simulateResiduals(fittedModel = model4, n = 500)
plot(residuals_simulation)

# Model diagnostics
check_model(model4)

# Check for influential cases potentially affecting the model
#influence_measures <- influence(model4)
#plot(influence_measures, which = "cook")

# If assumptions are not met, consider re-fitting the model with transformations or different specifications
# model_revised <- update(model, . ~ . + log(Reaction_Time))
# print(summary(model_revised))

# Model interpretation - examining fixed and random effects
fixed_effects <- fixef(model4)
random_effects <- ranef(model4)

# Printing fixed effects for interpretation
print(fixed_effects)

# Printing random effects for interpretation
print(random_effects)

# Estimate marginal means for all combinations
emm1 <- emmeans(model4, specs = ~ Phrase_Condition * Game_Version)
summary(emm1)

# Pairwise comparisons across phrase conditions within each game version
pairs(emm1, simple = "each")

plot(emm1)
```


## 5. Does the rate of improvement in each condition depend on the version?
### 5a: rt ~ 1 + time + condition * version + (1 + time + condition | participant)

1 (Intercept): Represents the baseline reaction time for the first question and the baseline categories of Phrase_Condition and Game_Version.

Question_Num: Continuous variable representing the sequential number of questions. A negative coefficient indicates improved reaction time (i.e., decreasing reaction time) as the game progresses.

Phrase_Condition * Game_Version: Examines if the effect of phrase conditions on reaction time is modified by the game version, identifying combinations where game version influences the difficulty of phrase conditions.

(1 | Player_ID): Random intercepts for players account for individual differences in baseline reaction times, acknowledging that some players generally respond faster or slower than others, independent of condition or version.

```{r }
model5 <- lmer(Reaction_Time ~ 1 + Question_Num + Phrase_Condition * Game_Version + (1 | Player_ID), data = data)

# Obtain and print a summary of the model to examine fixed and random effects
print(summary(model5))

#Diagnostic plots
plot_residuals_diagnostics(model5)

# Diagnostic checks - Simulating residuals to validate model assumptions
residuals_simulation <- simulateResiduals(fittedModel = model5, n = 500)
plot(residuals_simulation)

# Model diagnostics
check_model(model5)

# Check for influential cases potentially affecting the model
#influence_measures <- influence(model5)
#plot(influence_measures, which = "cook")

# If assumptions are not met, consider re-fitting the model with transformations or different specifications
# model_revised <- update(model, . ~ . + log(Reaction_Time))
# print(summary(model_revised))

# Model interpretation - examining fixed and random effects
fixed_effects <- fixef(model5)
random_effects <- ranef(model5)

# Printing fixed effects for interpretation
print(fixed_effects)

# Printing random effects for interpretation
print(random_effects)

# Estimate marginal means at various levels of Question_Num
emm2 <- emmeans(model5, specs = ~ Phrase_Condition * Game_Version, at = list(Question_Num = c(1, 10, 20)))
summary(emm2)

# Trend analysis
trend_analysis <- emtrends(model5, specs = ~ Phrase_Condition * Game_Version, var = "Question_Num")
summary(trend_analysis)

plot(emm2)

```

## Accuracy with logistic regression 

```{r}
# Define the function to plot diagnostics for logistic mixed-effects models
plotModelDiagnostics <- function(model, data) {
  # Deviance Residuals Plot
  dev_res <- resid(model, type = "deviance")
  plot(dev_res, ylim = c(min(dev_res), max(dev_res)), main = "Deviance Residuals")
  abline(h = 0, col = "red")
  
  # ROC Curve and AUC calculation
  probabilities <- predict(model, type = "response")
  actual <- data$Answer
  pred <- prediction(probabilities, actual)
  perf <- performance(pred, "tpr", "fpr")
  
  # Plot ROC Curve
  plot(perf, main = "ROC Curve")
  abline(0, 1, col = "blue")  # Adding diagonal line for reference
  
  # Calculate AUC and display it
  auc <- performance(pred, "auc")
  auc_value <- auc@y.values[[1]]
  cat("Area Under the Curve (AUC):", auc_value, "\n")
  
  # Simple plot just showing AUC value
  plot(1, type = "n", axes = FALSE, xlab = "", ylab = "", main = "AUC Value")
  text(1, 1, labels = paste("AUC =", round(auc_value, 3)), cex = 2)
}

# Example of using the function (you should already have a model fitted)
# plotModelDiagnostics(model1, data)
```

## 0. Accuracy marginalizing over everything

Accounting for variability among participants (participants as a random effect)
Oa: ac ~ 1 + (1 | participant)

```{r}
# Fit a basic logistic mixed-effects model
model0 <- glmer(Answer ~ 1 + (1 | Player_ID), data=data, family=binomial)

summary(model0)

plotModelDiagnostics(model0, data)
```
##Does learning take place?

1: ac - 1 + time + (1 + time | participant)

```{r}
control <- glmerControl(optimizer = "bobyqa", optCtrl = list(maxfun = 1000000))
model1 <- glmer(Answer ~ 1 + Question_Num + (1 + Question_Num | Player_ID), data = data, family = binomial, control = control)

summary(model1)

plotModelDiagnostics(model1, data)

```

## 2. Which condition is hardest overall?

2: ac - 1 + condition + (1 + condition | participant)


```{r}
control <- glmerControl(optimizer = "bobyqa", optCtrl = list(maxfun = 1000000))
model2 <- glmer(Answer ~ 1 + Phrase_Condition + (1 + Phrase_Condition | Player_ID), data = data, family = binomial, control = control)


# Output the summary of the model to see the results
summary(model2)

plotModelDiagnostics(model2, data)
```

##Does the version of the experiment cause different outcomes?

ac - 1 + version + ((1 | participant)

```{r}
control <- glmerControl(optimizer = "bobyqa", optCtrl = list(maxfun = 1000000))
model3 <- glmer(Answer ~ 1 + Game_Version + (1 | Player_ID), data = data, family = binomial, control = control)


summary(model3)

plotModelDiagnostics(model3, data)
```

##Hoes does the effect of condition vary depending on the version?

ac - 1 + condition * version + (1 + condition | participant)

```{r}
control <- glmerControl(optimizer = "bobyqa", optCtrl = list(maxfun = 1000000))
model4 <- glmer(Answer ~ 1 + Phrase_Condition * Game_Version + (1 | Player_ID), data = data, family = binomial, control = control)

summary(model4)

plotModelDiagnostics(model4, data)

```


